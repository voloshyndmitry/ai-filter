<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Topic Filter • Apple Flyouts</title>
    <!-- Materialize CSS (simple Material UI) -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background: #fafafa;
      }
      .container {
        max-width: 980px;
      }
      pre {
        white-space: pre-wrap;
      }
      .chips-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .chip {
        margin: 0;
      }
      .section-card {
        padding: 16px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      .dim {
        color: #757575;
      }
      .nowrap {
        white-space: nowrap;
      }
      .spinner {
        display: none;
      }
      .spinner.active {
        display: inline-block;
      }
      .topic-badge {
        font-size: 0.85rem;
      }
      .small {
        font-size: 0.9rem;
      }
      .material-icons {
        vertical-align: middle;
      }
      .fixed-action-btn {
        bottom: 24px;
        right: 24px;
      }
    </style>
  </head>
  <body>
    <nav class="blue-grey darken-3">
      <div class="nav-wrapper container">
        <a href="#" class="brand-logo">AI Topic Filter</a>
      </div>
    </nav>

    <div class="container">
      <div class="section">
        <h5>1) Load topics from Apple</h5>
        <p class="dim">
          Endpoint:
          <span class="mono"
            >https://www.apple.com/api-www/global-elements/global-header/v1/flyouts?locale=en_US</span
          >
        </p>
        <div class="row">
          <div class="col s12 m9">
            <a id="btnFetch" class="btn waves-effect waves-light">
              <i class="material-icons left">cloud_download</i>Fetch Apple
              Topics
            </a>
            <div
              id="fetchStatus"
              class="small dim"
              style="margin-top: 8px"
            ></div>
          </div>
        </div>
        <div id="topicsCard" class="card section-card">
          <div class="row" style="margin-bottom: 0">
            <div class="col s12">
              <div class="chips-container" id="topicsChips"></div>
              <div
                class="small dim"
                id="topicsMeta"
                style="margin-top: 6px"
              ></div>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h5>2) Try a user phrase</h5>
        <div class="row">
          <div class="input-field col s12 m8">
            <input
              id="userText"
              type="text"
              placeholder="e.g., Any phone or Mac events next month?"
            />
            <label for="userText" class="active">User input (English)</label>
          </div>
          <div class="input-field col s6 m2">
            <input id="minScore" type="number" step="0.1" value="1" />
            <label for="minScore" class="active">minScore</label>
          </div>
          <div class="input-field col s6 m2">
            <input id="topK" type="number" value="5" />
            <label for="topK" class="active">topK</label>
          </div>
        </div>
        <div class="row">
          <div class="col s12 m6">
            <a id="btnInfer" class="btn waves-effect waves-light">
              <i class="material-icons left">Find topic</i>Infer Topics
            </a>
          </div>
        </div>

        <ul class="collection" id="resultsList"></ul>
      </div>

      <div class="section">
        <h6>Debug</h6>
        <details>
          <summary class="small">Show raw model/topics</summary>
          <pre id="debugArea" class="mono"></pre>
        </details>
      </div>
    </div>

    <!-- Materialize JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <script>
      // ===================== Utilities =====================
      const STOPWORDS = new Set([
        "i",
        "me",
        "my",
        "myself",
        "we",
        "our",
        "ours",
        "ourselves",
        "you",
        "your",
        "yours",
        "yourselves",
        "he",
        "him",
        "his",
        "she",
        "her",
        "they",
        "them",
        "their",
        "theirs",
        "it",
        "its",
        "is",
        "am",
        "are",
        "was",
        "were",
        "be",
        "been",
        "being",
        "the",
        "a",
        "an",
        "and",
        "or",
        "but",
        "to",
        "for",
        "of",
        "on",
        "in",
        "with",
        "about",
        "into",
        "from",
        "at",
        "by",
        "as",
        "that",
        "this",
        "these",
        "those",
        "there",
        "here",
        "what",
        "which",
        "who",
        "whom",
        "when",
        "where",
        "why",
        "how",
        "do",
        "does",
        "did",
        "doing",
        "would",
        "should",
        "could",
        "can",
        "will",
        "just",
        "so",
        "if",
        "than",
        "then",
      ]);

      function normalize(text) {
        return String(text || "")
          .toLowerCase()
          .replace(/[^a-z0-9\s\-\+\/\.]/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function tokenize(text) {
        const tokens = normalize(text).split(" ");
        return tokens.filter((token) => token && !STOPWORDS.has(token));
      }

      function variants(word) {
        const variantsSet = new Set([word]);
        if (word.endsWith("ies") && word.length > 3) {
          variantsSet.add(word.slice(0, -3) + "y");
        }
        if (word.endsWith("s") && !word.endsWith("ss")) {
          variantsSet.add(word.slice(0, -1));
        }
        if (word.endsWith("es")) {
          variantsSet.add(word.slice(0, -2));
        }
        return Array.from(variantsSet);
      }
      function levenshtein(stringA, stringB) {
        if (stringA === stringB) return 0;
        if (!stringA.length) return stringB.length;
        if (!stringB.length) return stringA.length;
        const dp = Array(stringB.length + 1)
          .fill(0)
          .map((_, i) => i);
        for (let i = 0; i < stringA.length; i++) {
          let prev = i + 1;
          for (let j = 0; j < stringB.length; j++) {
            const tmp = dp[j + 1];
            dp[j + 1] = Math.min(
              dp[j + 1] + 1,
              prev + 1,
              dp[j] + (stringA[i] === stringB[j] ? 0 : 1)
            );
            prev = tmp;
          }
          dp[0] = i + 1;
        }
        return dp[stringB.length];
      }

      // Derived synonyms for labels like "iPhone" -> "phone"
      function deriveSynonymsFromLabel(label) {
        const normalizedLabel = normalize(label);
        const syns = new Set();
        const words = normalizedLabel.split(" ");
        for (const word of words) {
          if (word.length > 2 && word[0] === "i" && /[a-z]/.test(word[1])) {
            syns.add(word.slice(1)); // iphone->phone
          }
        }
        if (
          /\bphone\b/.test(normalizedLabel) ||
          /iphone/.test(normalizedLabel)
        ) {
          syns.add("phone");
          syns.add("smartphone");
          syns.add("mobile");
          syns.add("mobile phone");
          syns.add("cell phone");
          syns.add("apple phone");
        }
        normalizedLabel.split(/[\/\+]/).forEach((part) => {
          const trimmed = part.trim();
          if (trimmed && trimmed !== normalizedLabel) syns.add(trimmed);
        });
        return Array.from(syns);
      }

      // ===================== Building the topic model =====================
      function buildTopicModel(topics, options = {}) {
        const { synonyms = {}, extraPhrases = {}, negatives = {} } = options;
        return topics.map((raw, idx) => {
          const label = String(raw).trim();
          const id = normalize(label).replace(/\s+/g, "_") || `topic_${idx}`;
          const words = tokenize(label);
          const keywordSet = new Set();
          for (const word of words) {
            variants(word).forEach((variant) => keywordSet.add(variant));
          }
          const providedSyns =
            synonyms[label] || synonyms[id] || synonyms[words[0]] || [];
          for (const synonym of providedSyns) {
            tokenize(synonym).forEach((word) =>
              variants(word).forEach((variant) => keywordSet.add(variant))
            );
          }
          const derived = deriveSynonymsFromLabel(label);
          for (const synonym of derived) {
            tokenize(synonym).forEach((word) =>
              variants(word).forEach((variant) => keywordSet.add(variant))
            );
          }
          const phrases = [
            label.toLowerCase(),
            ...(extraPhrases[label] || extraPhrases[id] || []),
          ].map(normalize);
          const neg = (negatives[label] || negatives[id] || []).map(normalize);
          return {
            id,
            label,
            keywords: Array.from(keywordSet),
            phrases,
            negatives: neg,
          };
        });
      }

      function scoreTopic(text, tokens, topic) {
        const textNorm = normalize(text);
        for (const negative of topic.negatives || []) {
          if (textNorm.includes(negative)) return 0;
        }
        let score = 0;
        for (const phrase of topic.phrases || []) {
          if (phrase && textNorm.includes(phrase)) score += 3;
        }
        const tokenSet = new Set(tokens);
        for (const keyword of topic.keywords || []) {
          if (tokenSet.has(keyword)) score += 1.5;
        }
        for (const token of tokens) {
          for (const keyword of topic.keywords || []) {
            const d = levenshtein(token, keyword);
            if (
              (keyword.length <= 4 && d === 1) ||
              (keyword.length > 4 && d <= 2)
            ) {
              score += 0.5;
            }
            const minCore = 5;
            if (
              token.length >= minCore &&
              keyword.length >= minCore &&
              (token.includes(keyword) || keyword.includes(token))
            ) {
              score += 1.0;
            }
          }
        }
        return score;
      }

      function inferTopics(text, model, options = {}) {
        const { minScore = 1.0, topK = 5 } = options;
        const tokens = tokenize(text);
        const scored = model
          .map((topic) => ({
            id: topic.id,
            label: topic.label,
            score: scoreTopic(text, tokens, topic),
          }))
          .filter((topicScore) => topicScore.score >= minScore)
          .sort((topicA, topicB) => topicB.score - topicA.score)
          .slice(0, topK);
        if (scored.length > 0) {
          const max = scored[0].score || 1;
          for (const scoredItem of scored) {
            scoredItem.confidence = +(scoredItem.score / max).toFixed(2);
          }
        }
        return scored;
      }

      /** Extract only main topics and subtopics from Apple flyouts JSON */
      function extractAppleTopics(json) {
        const topics = new Set();
        const items = Array.isArray(json)
          ? json
          : Array.isArray(json?.items)
          ? json.items
          : [];
        for (const item of items) {
          if (!item || typeof item !== "object") continue;
          // main topic: item.name
          if (item.name) topics.add(String(item.name));
          // subtopics from elevatedGroups.elevatedLinks[].text
          (item.elevatedGroups || []).forEach((g) =>
            (g?.elevatedLinks || []).forEach((l) => {
              if (l?.text) topics.add(String(l.text));
            })
          );
          // subtopics from baseGroups.baseLinks[].text
          (item.baseGroups || []).forEach((g) =>
            (g?.baseLinks || []).forEach((l) => {
              if (l?.text) topics.add(String(l.text));
            })
          );
        }
        // Clean & dedupe: remove very short generic words
        const cleaned = Array.from(topics)
          .map((topic) => topic.trim())
          .filter((topic) => topic && topic.length >= 2)
          .filter((topic) => !/^learn more$/i.test(topic));
        return cleaned;
      }

      // ===================== UI Logic =====================
      let topicStrings = [];
      let model = [];

      const btnFetch = document.getElementById("btnFetch");
      const fetchStatus = document.getElementById("fetchStatus");
      const topicsChips = document.getElementById("topicsChips");
      const topicsMeta = document.getElementById("topicsMeta");
      const userTextEl = document.getElementById("userText");
      const minScoreEl = document.getElementById("minScore");
      const topKEl = document.getElementById("topK");
      const btnInfer = document.getElementById("btnInfer");
      const resultsList = document.getElementById("resultsList");
      const debugArea = document.getElementById("debugArea");

      function renderChips(list) {
        topicsChips.innerHTML = "";
        list.forEach((topic) => {
          {
            const chip = document.createElement("div");
            chip.className = "chip topic-badge";
            chip.textContent = topic;
            topicsChips.appendChild(chip);
          }
        });
        topicsMeta.textContent = list.length
          ? `${list.length} topics loaded`
          : "No topics loaded yet";
      }

      function renderResults(items) {
        resultsList.innerHTML = "";
        if (!items.length) {
          resultsList.innerHTML = '<li class="collection-item">No matches</li>';
          return;
        }
        for (const result of items) {
          {
            const li = document.createElement("li");
            li.className = "collection-item";
            li.innerHTML = `<span class="title"><strong>${
              result.label
            }</strong></span><br/><span class="dim small">score: ${result.score.toFixed(
              2
            )} · confidence: ${result.confidence}</span>`;
            resultsList.appendChild(li);
          }
        }
      }

      btnFetch.addEventListener("click", async () => {
        fetchStatus.textContent = "Fetching…";
        try {
          const response = await fetch("/data.json", { mode: "cors" });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          topicStrings = extractAppleTopics(data);
          renderChips(topicStrings);
          // Build model with a few helpful synonyms for common Apple terms
          model = buildTopicModel(topicStrings, {
            synonyms: {
              iphone: ["phone", "smartphone", "mobile"],
              ipad: ["tablet"],
              mac: ["macbook", "laptop", "desktop", "mac os", "macos"],
              watch: ["apple watch", "smartwatch"],
              accessories: ["case", "charger", "cable", "keyboard", "mouse"],
              vision: [
                "apple vision pro",
                "vision pro",
                "headset",
                "xr",
                "spatial",
              ],
              trade: ["trade in", "trade-in"],
              financing: ["payment plan"],
            },
          });
          debugArea.textContent = JSON.stringify(
            { topics: topicStrings.slice(0, 50), modelSize: model.length },
            null,
            2
          );
          fetchStatus.textContent = "Done";
          M.toast({ html: `Loaded ${topicStrings.length} topics` });
        } catch (err) {
          console.error(err);
          fetchStatus.innerHTML = `<span class="red-text">Failed: ${err.message}. If blocked by CORS, use a small dev proxy.</span>`;
          M.toast({ html: "Fetch failed (see console)" });
        }
      });

      btnInfer.addEventListener("click", () => {
        const text = userTextEl.value || "";
        const minScore = parseFloat(minScoreEl.value || "1") || 1;
        const topK = parseInt(topKEl.value || "5", 10) || 5;
        if (!text.trim()) {
          M.toast({ html: "Enter a user phrase first" });
          return;
        }
        if (!model.length) {
          M.toast({ html: "Load topics first" });
          return;
        }
        const results = inferTopics(text, model, { minScore, topK });
        renderResults(results);
      });

      // Prefill example for quick testing
      userTextEl.value = "Looking for phone, Mac or Vision Pro events";
      M.updateTextFields();
    </script>
  </body>
</html>
